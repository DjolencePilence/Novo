package rs.ac.bg.etf.pp1;
import java_cup.runtime.*;
//import java.io.*;
import org.apache.log4j.*;
import java.util.Stack;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;

parser code {:
	
	int numGlobVar = 0;
	int numGlobConst = 0;
	int numGlobArrays = 0;
	int numLocalVar = 0;
	int printCallCount = 0;
	int numFuncCallsInMain = 0;
	int numFormParam = 0;
	int numGlobFunc = 0;
	int numStaticFunc = 0;
	
	boolean insideOfClass = false;
	boolean isStaticFunc = false;
	
	Struct boolType = null;
	
	
	Stack<String> stack = new Stack<String>();
	
	Logger log = Logger.getLogger(getClass());
   
   	//Metoda za ispis nadjenih simbola
   	private String stringKind(int kind){
	   	switch(kind){
	   			case 0: return "noType";
	   			case 1: return "int" ;
	   			case 2: return "char";
	   			case 3: return "Arr of ";
	   			case 4: return "Class";
	   			case 5: return "bool";
	   			default: return " ";
	   		}
   	}
   
   	public void printSymbol(int numLine, String varIdent, Obj node){
   		int kind = node.getType().getKind();
   		String tip = stringKind(kind);
   		if(kind ==3) tip += stringKind(node.getType().getElemType().getKind());
   		if(node.getLevel()==0){
			if(node.getKind()== Obj.Con)
				report_info("Pretraga na " + numLine + "("+varIdent+"), nadjeno Con " + varIdent +" " + tip+ ", "+node.getAdr() +","+node.getLevel(), null);
			else
				report_info("Pretraga na " + numLine + "("+varIdent+"), nadjeno Var " + varIdent +" " + tip+ ", "+node.getAdr() +","+node.getLevel(), null);
			}
		else
			report_info("Pretraga na " + numLine + "("+varIdent+"), nadjeno Var " + varIdent +" " + tip+ ", "+node.getAdr() +","+node.getLevel(), null);
   			
   	}
   	public Obj checkExistence(int numLine, String varIdent){
   			Obj node = Tab.find(varIdent);
	   		if(node == Tab.noObj) 
	   			report_error("Greska na " + numLine +" ("+ varIdent + ") nije nadjeno", null);
	   		else{
	   			printSymbol(numLine, varIdent, node);
	   		}
	   		return node;
   	}
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

init with {:
	stack.push("global");
	Tab.init();
	boolType = new Struct(Struct.Bool);
	Tab.currentScope.addToLocals(new Obj(Obj.Type,"bool",boolType));
:}

action code {:
	Struct typeName = null;
	String varIdent = null;
	String constIdent = null;
	int numLine = 0;
	
	Struct returnValue = null;
	Obj currentMethod = null;
	boolean returnFound = false;
	Scope mainScope = null;
:}


terminal Integer NUMBER;
terminal String IDENT;
terminal PROG, PRINT, RETURN, EXTENDS, NEW, ELSE, IF, FOR, STATIC, CONST, BREAK, READ, CLASS, CONTINUE, CHAR, BOOL;
terminal PLUS, EQUAL, COMMA, SEMI, LPAREN, RPAREN, LBRACE, RBRACE, LZAG, RZAG, MINUS, MULTIPLY, DIVIDE, PLUSEQUAL, MINUSEQUAL;
terminal MULTIPLYEQUAL, DIVIDEEQUAL, MOD, EE, NOTEQUAL, LESS, LESSEQUAL, GREATER, GREATEREQUAL, ME, AND, OR, PLUSPLUS, MINUSMINUS;
terminal POINT, VOID;
non terminal Program, DeclarationList, Declaration, ConstDecl, VarDecl, MethodDecl, MethodDeclList, ConstType, ConstDeclArray;
non terminal VarDeclZag, VarDeclArray, ClassDecl, ClassExtends, VarDeclListOptional, MethodDeclListOptional, StaticOptional;
non terminal VarDeclList, FormalParamList, FormalParam, StatementList, Statement, DesignatorStatement;
non terminal Condition, DesignatorStatementOptional, ConditionOptional, ActParsList, ActPars;
non terminal CondTerm, CondFact, CondFactList, CondTermList, Assignop, AddopLeft, AddopRight, MulopLeft, MulopRight, Relop;
non terminal RelExprOptional,  FactorExprOptional, DesignatorList, DeclarationListOptional ;
non terminal ClassVarDeclListOptional, ClassVarDeclList, ClassVarDeclArray, ClassVarDecl;
non terminal VarArgs, Parameters;
non terminal DesignatorListElement;
non terminal GlobVarDecl, GlobVarDeclZag, GlobVarDeclArray;
non terminal Obj ProgName;
non terminal Struct Type;
non terminal GlobVarTypeAndName;
non terminal VariableName;
non terminal ConstName, TypeOfConstant;
non terminal Struct RetValue;
non terminal LocalVarType;
non terminal FormVarDeclZag;
non terminal Obj Designator;
non terminal Struct  Expr, Factor, Term;
non terminal Struct FactorExpr, FactorExprLeft;
non terminal Struct SubExpr, SubExprLeft;

precedence left ELSE;

Program ::= PROG ProgName:p DeclarationListOptional LBRACE MethodDeclList RBRACE
{:
	Tab.chainLocalSymbols(p);
	Tab.closeScope();
:};

ProgName ::= IDENT:pName
{:
	RESULT = Tab.insert(Obj.Prog, pName, Tab.noType);
	Tab.openScope();
	mainScope = Tab.currentScope;
:};

DeclarationListOptional ::= DeclarationList
							|
							/* */
							;

DeclarationList ::= Declaration DeclarationList
					|
					Declaration;
					
Declaration ::=	ConstDecl
				|
				GlobVarDecl
				|
				ClassDecl
				;

// Deklaracija KONSTANTI
		
ConstType ::= BOOL
			  |
			  NUMBER
			  |
			  CHAR;
		
ConstDeclArray ::= COMMA ConstName EQUAL ConstType ConstDeclArray
				 |
				 COMMA ConstName EQUAL ConstType SEMI; 

TypeOfConstant ::= Type:constType
{:
	typeName = constType;
:};

ConstName ::= IDENT:constName
{:	
	parser.numGlobConst++;
	constIdent = constName;
	numLine = constNameleft;
	Obj node = Tab.find(constName);
	if(node != Tab.noObj) parser.report_error("Vec je deklarisana konstanta sa imenom " + constName,null);
	else{
		parser.report_info("Definisana konstanta " + constIdent+ " na liniji " + numLine, null);
		Tab.insert(Obj.Con, constIdent, typeName);
	}
:};
	
ConstDecl ::= CONST	TypeOfConstant ConstName EQUAL ConstType SEMI
			  |
			  CONST	TypeOfConstant ConstName EQUAL ConstType ConstDeclArray;  

//Kraj deklaracije KONSTANTI

// GLOBAL VARIABLES AND ARRAYS START ------------------------------------------

GlobVarDeclZag ::= LZAG RZAG
					{:  parser.numGlobArrays++; parser.numGlobVar++;
						Obj node = Tab.find(varIdent);
						if(node != Tab.noObj && mainScope ==Tab.currentScope) parser.report_error("Vec je deklarisan niz sa imenom " + varIdent,null);
				  		else{
							parser.report_info("Deklarisan globalni niz " + varIdent+ " na liniji " + numLine, null);
							Tab.insert(Obj.Var, varIdent, new Struct(Struct.Array,typeName));
						}
					
					:}
					|
					/*epsilon*/ 
					{:  parser.numGlobVar++;
						Obj node = Tab.find(varIdent);
						if(node != Tab.noObj && mainScope ==Tab.currentScope) parser.report_error("Vec je deklarisana promenljiva sa imenom " + varIdent,null);
				  		else{
							parser.report_info("Deklarisana globalna promenljiva " + varIdent+ " na liniji " + numLine, null);
							Tab.insert(Obj.Var, varIdent, typeName);
						}
					:}
					;
					
VariableName ::= IDENT:varName
{:
	numLine = varNameleft;
	varIdent = varName;
:};
					
GlobVarDeclArray ::= COMMA VariableName GlobVarDeclZag GlobVarDeclArray
					 |
					 COMMA error GlobVarDeclArray
					 |
					 COMMA VariableName  GlobVarDeclZag SEMI
					 |
					 COMMA error SEMI;

GlobVarTypeAndName ::= Type:varType IDENT:varName
{:
					varIdent = varName;
					typeName = varType;
					numLine = varNameleft;
:};

				 		  
GlobVarDecl ::= GlobVarTypeAndName GlobVarDeclZag SEMI
				|
				error SEMI
				|
				GlobVarTypeAndName GlobVarDeclZag GlobVarDeclArray
				;


// GLOBAL VARIABLES AND ARRAYS END ------------------------------------------

//LOCAL VARIABLES -----------------------------------------------------------

LocalVarType ::= Type:varType 
{:
	typeName = varType;
:};

VarDeclZag ::= LZAG RZAG
				{: if("main".equals(parser.stack.peek())) parser.numLocalVar++; 
				  	//check if already exists
				  	Obj node = Tab.find(varIdent);
				  	if(node != Tab.noObj && mainScope ==Tab.currentScope) parser.report_error("Vec je deklarisan niz sa imenom " + varIdent,null);
				  	else{
						parser.report_info("Deklarisan lokalni niz " + varIdent+ " na liniji " + numLine, null);
						Tab.insert(Obj.Var, varIdent, new Struct(Struct.Array,typeName));
					}
				:}
				|
				/*epsilon*/
				{:  if("main".equals(parser.stack.peek())) parser.numLocalVar++;
					Obj node = Tab.find(varIdent); 
					if(node != Tab.noObj && mainScope ==Tab.currentScope) parser.report_error("Vec je deklarisana promenljiva sa imenom " + varIdent,null);
				  	else{
						parser.report_info("Deklarisana lokalna promenljiva " + varIdent+ " na liniji " + numLine, null);
						Tab.insert(Obj.Var, varIdent, typeName);
					}
				:}
				;
				
VarDeclArray ::= COMMA VariableName VarDeclZag VarDeclArray
				 |
				 COMMA VariableName VarDeclZag SEMI;
				 		  
VarDecl ::= LocalVarType VariableName VarDeclZag SEMI
			|
			error SEMI
			|
			error
			|
			LocalVarType VariableName VarDeclZag VarDeclArray;

VarDeclList ::= VarDeclList VarDecl
				|
				VarDecl;

VarDeclListOptional ::= VarDeclList
					|
					/*epsilon*/
					;
// LOCAL VARIABLES END ---------------------------------------------------

// CLASSES START ---------------------------------------------------------
			
ClassExtends ::= EXTENDS Type
				 |
				 /* epsilon */
				 ;
// MODIFIKACIJA 1    JUL
ClassVarDeclListOptional ::= ClassVarDeclList
							|
							/*epsilon */
							;
ClassVarDeclList ::= ClassVarDeclList ClassVarDecl 
					 |
					 ClassVarDecl
					 ;
ClassVarDeclArray ::= COMMA VariableName VarDeclZag ClassVarDeclArray
					  |
					  COMMA VariableName VarDeclZag SEMI;
					  
ClassVarDecl ::= StaticOptional LocalVarType VariableName VarDeclZag SEMI
				|
				StaticOptional LocalVarType VariableName VarDeclZag ClassVarDeclArray;
							
ClassDecl ::= CLASS IDENT:className {:	  parser.insideOfClass=true;
										  Tab.insert(Obj.Type,className,Tab.nullType );
										  Tab.openScope();
								    :} ClassExtends LBRACE ClassVarDeclListOptional MethodDeclListOptional RBRACE
									{:	   parser.insideOfClass = false;
										   Obj node = Tab.find(className);
										   Tab.chainLocalSymbols(node);
										   Tab.closeScope();
									:};

// METHOD STARTS -----------------------------------------------------

MethodDeclListOptional ::= LBRACE MethodDeclList RBRACE
						|
					   /*epsilon */
					   ;
					   							


MethodDeclList ::= MethodDeclList MethodDecl
					|
				   MethodDecl
				   ;
				   
StaticOptional ::= STATIC
				   {: parser.isStaticFunc=true; :}
				   |
				   /*epsilon */
				   {: parser.isStaticFunc=false; :}
				   ;
RetValue ::= VOID {: RESULT = Tab.noType; :}
			|
			Type {: RESULT = returnValue; :};

//FormPars ::= FormalParamList
//			|
//			/*epsilon*/
//			;
			
FormalParamList ::= FormalParamList COMMA FormalParam
					{:parser.numFormParam++; :}
					|
					FormalParam
					{:parser.numFormParam++; :}
					;

FormVarDeclZag ::= LZAG RZAG
				 |
				 /*	epsilon */
				 ;

FormalParam ::= Type IDENT FormVarDeclZag
				|
				error;
 							
VarArgs ::= Type POINT POINT POINT IDENT;

Parameters ::= FormalParamList COMMA VarArgs
			   |
			   VarArgs
			   |
			   FormalParamList
			   |
			   /*epsilon */
			  	;
MethodDecl ::= StaticOptional RetValue:retVal IDENT:name
			   {:	if(parser.isStaticFunc && parser.insideOfClass) parser.numStaticFunc++;
			   
			   		currentMethod = Tab.insert(Obj.Meth, name, retVal);
			   		returnValue = null;
			   		Tab.openScope();
			   		parser.report_info("Obradjuje se funkcija "+name+" na liniji "+nameleft,null);
			   :}
			  LPAREN Parameters RPAREN {: if("main".equals(name)) parser.stack.push("main"); else parser.stack.push("local"); :} VarDeclListOptional
			   {:   :}LBRACE StatementList RBRACE
			   {:	
			   		if (!returnFound && retVal != Tab.noType)
			   	 		parser.report_error("Semanticka greska na liniji " + nameleft + ": funcija " + name + " nema return iskaz!", null);
			   		parser.stack.pop();
			   		if(!parser.insideOfClass) parser.numGlobFunc++;
					Tab.chainLocalSymbols(currentMethod);
					Tab.closeScope();
					currentMethod = null;
					returnFound = false;			   	
			   :};
// METHOD STARTS ----------------------------------------------------
// CLASSES END -------------------------------------------------------
				
StatementList ::= StatementList Statement
				 |
				 /* */
				 ;

Type ::= IDENT:typeName
{:
	Obj typeNode = Tab.find(typeName);
	if(typeNode ==Tab.noObj){
		parser.report_error("Nije pronadjen tip " + typeName + " u tabeli simbola ", null );
		RESULT = Tab.noType;
	}
	else{
		if(Obj.Type == typeNode.getKind()){
		returnValue = typeNode.getType();
		RESULT = typeNode.getType();
		}
		else {
		parser.report_error("Greska na liniji "+ typeNameleft +  ":Ime " + typeName + " ne predstavlja ime tipa", null);
		RESULT = Tab.noType;
		}
		
	}
	
:}
;


ConditionOptional ::= Condition 
					 |
					 error
					 |
					 /* */
					 ;
					 
DesignatorStatementOptional ::= DesignatorStatement
								|
								error
								|
								/* */
								;

Statement ::= DesignatorStatement SEMI
			  |
			  IF LPAREN Condition RPAREN Statement ELSE Statement
			  |
			  IF LPAREN error RPAREN Statement ELSE Statement
			  |
			  IF LPAREN Condition RPAREN Statement
			  |
			  IF LPAREN error RPAREN Statement
			  |
			  FOR LPAREN DesignatorStatementOptional SEMI ConditionOptional SEMI DesignatorStatementOptional  RPAREN Statement
			  |
			  BREAK SEMI
			  |
			  CONTINUE SEMI
			  |
			  RETURN Expr:t SEMI
			  {:
			  	 returnFound = true;
				 Struct currMethType = currentMethod.getType();
				 if (t!=null && !currMethType.assignableTo(t)) {
				 	parser.report_error("Greska na liniji " + tleft + " : " + "tip izraza u return naredbi ne slaze se sa tipom povratne vrednosti funkcije " + currentMethod.getName(), null);
				 }	
			  :}
			  |
			  RETURN SEMI
			  |
			  READ LPAREN Designator RPAREN SEMI
			  {:if("main".equals(parser.stack.peek())) parser.numFuncCallsInMain++;:}
			  |
			  PRINT LPAREN Expr RPAREN SEMI
			  {:if("main".equals(parser.stack.peek())) parser.numFuncCallsInMain++;:}
			  |
			  PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
			  {:if("main".equals(parser.stack.peek())) parser.numFuncCallsInMain++;:}
			  |
			  LBRACE StatementList RBRACE;

ActPars ::= ActParsList
			{: if("main".equals(parser.stack.peek())) parser.numFuncCallsInMain++; :}
			|
			/* */
			{: if("main".equals(parser.stack.peek())) parser.numFuncCallsInMain++; :}
			;
ActParsList ::= ActParsList COMMA Expr
				|
				Expr;


// Dodavanje zbog greske prilikom dodele			  
 DesignatorStatement ::= Designator:d Assignop:assignLine Expr:e
 						{: 
	 						if(d!=Tab.noObj && e!=null){
	 							Struct tip = d.getType();
	 								if(tip.getKind() == Struct.Array){
	 								 	if(!e.assignableTo(tip.getElemType()))
	 								 		parser.report_error("Greska na liniji "+ assignLineleft +  " nekompatibilni tipovi ", null);
	 								}
	 								else 
	 									if(!e.assignableTo(tip))
	 								 		parser.report_error("Greska na liniji "+ assignLineleft +  " nekompatibilni tipovi", null);
	 								
	 							}
 						:}
 						|
 						Designator Assignop error
 						|
 						 Designator LPAREN ActPars RPAREN
 						|
 						 Designator PLUSPLUS
 						|
 						 Designator MINUSMINUS;
 
 RelExprOptional ::= Relop Expr
 					|
 					 /* */
 					;
 
// AddopList ::= AddopList Addop Term
// 				|
// 			   /* */
// 			   ;
 
//Expr ::= MINUS Term:t {: RESULT = t; :} AddopList
// 		  |
// 		  Term:t 	 {: RESULT = t; :} AddopList;

Expr ::= SubExpr:se {: RESULT = se; :};

SubExpr ::= SubExpr:se AddopRight SubExprLeft:sel
			{:
				if(se!=null && sel!=null)
					if(!se.assignableTo(sel)) parser.report_error("nekompatibilni tipovi na liniji "+selleft,null);
				RESULT = se;
			:}
			|
			SubExprLeft:sel {: RESULT = sel;:}
			;
			
SubExprLeft ::= Term:t AddopLeft SubExprLeft:sel
				{:
					if(t!=null && sel!=null)
						if(!t.assignableTo(sel)) parser.report_error("nekompatibilni tipovi na liniji "+selleft,null);
					RESULT = t;
				:}
				|
			   	MINUS Term:t AddopLeft SubExprLeft:sel
			   	{:
					if(t!=null && sel!=null)
						if(!t.assignableTo(sel)) parser.report_error("nekompatibilni tipovi na liniji "+selleft,null);
					RESULT = t;
				:}
				|
				Term:t {: RESULT = t; :}
				|
				MINUS Term:t {: RESULT = t; :}
				;
				
//Term ::= Factor:f {: RESULT = f; :} MulopList;

//MulopList ::= MulopList Mulop Factor
//			 |
//			  /* */
//			  ;
Term ::= FactorExpr:fe {: RESULT = fe; :};

FactorExpr ::= FactorExpr:fe MulopRight:mop FactorExprLeft:fel
				{:
					if(fe!=null && fel!=null){
					   		if(!fe.assignableTo(fel)) parser.report_error("nekompatibilni tipovi na liniji "+felleft,null);
					     }
					RESULT = fe;
				  :}
				|
				FactorExprLeft:fel
				{:
					RESULT = fel;
				:}
				;
				
FactorExprLeft ::= Factor:f MulopLeft FactorExprLeft:fel
				   {: 
					   if(f!=null && fel!=null){
					   		if(!f.assignableTo(fel)) parser.report_error("nekompatibilni tipovi na liniji "+felleft,null);
					     } 
					     RESULT = f;
				    :}
					|
				   Factor:f
				   {: if(f!=null) RESULT = f; :}
				   ;

FactorExprOptional ::= LZAG Expr RZAG
					   |
					   /* */
					   ;

Factor ::= Designator:d 
		 	{: 		
		 				if(d.getType().getKind()==Struct.Array) RESULT = d.getType().getElemType();
					  	else RESULT = d.getType();
			:}
			| 
		   Designator LPAREN ActPars RPAREN
			|
		   NUMBER {: RESULT = Tab.intType; :}
		   |
		   CHAR   {: RESULT = Tab.charType; :}
		   |
		   BOOL	  {: RESULT = parser.boolType; :}
		   |
		   NEW Type FactorExprOptional
		   |
		   LPAREN Expr RPAREN;

DesignatorListElement ::= POINT IDENT:varName
						  {: :}
						   |
						  LZAG Expr:e RZAG
						  ;

DesignatorList ::=  DesignatorList DesignatorListElement
					|
					DesignatorListElement
					;
					

Designator ::= IDENT:varName DesignatorList
			    {: 
			   		RESULT = parser.checkExistence(varNameleft, varName);
			    :}
				|
			   IDENT:varName {:
			   		numLine = varNameleft;
			   		varIdent = varName;
			   		
			   		RESULT = parser.checkExistence(numLine, varIdent);
			   	:};



 
 CondFact ::= Expr RelExprOptional;
 
 
 CondFactList ::= CondFact
 				  |
 				  CondFact AND CondFactList;
 
 CondTerm ::= CondFactList;
 
 CondTermList::= CondTerm
 				 |
 				 CondTerm OR CondTermList;
 
 Condition ::= CondTermList;
 
 
 Assignop ::= EQUAL
 			  |
 			  AddopRight
 			  |
 			  MulopRight;
 
 AddopRight ::= PLUSEQUAL
 				|
 				MINUSEQUAL;
 				
 MulopRight ::= MULTIPLYEQUAL
 				|
 				DIVIDEEQUAL
 				|
 				ME;
 
// Addop ::= AddopRight
// 			|
// 		   AddopLeft;
 
 AddopLeft ::= PLUS
 				|
 			   MINUS;
 			   
 //Mulop ::= MulopLeft
 //		   |
 //		   MulopRight;
 		   
 MulopLeft ::= MULTIPLY
 			   |
 			   DIVIDE
 			   |
 			   MOD;
 			   
 Relop ::= EE
 		   |
 		   NOTEQUAL
 		   |
 		   LESS
 		   |
 		   LESSEQUAL
 		   |
 		   GREATER
 		   |
 		   GREATEREQUAL;